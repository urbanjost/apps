! $Id: FF08Diff.f90 2344 2016-08-17 16:05:44Z ian $
! ff08 source code copyright 2015 M.E.G.M.S.  See LICENCE.txt for licence.
!> @file
!! Defines the FF08Diff program.


!*******************************************************************************
!!
!> Main program for FF08Diff.
!!
!! Program manual stuff
!! ====================
!!
!! Describe the semantic differences between two sets of Fortran source files.
!!
!! Usage:
!!  FF08Diff [options] source-file-specs... [--right source-file-specs...]
!!
!! Command line options:
!!
!! - -> or --help      Display command line and program usage help, then exit.
!!
!! --version           Display program version information, then exit.
!!
!! -l or --left        Source file specifications following this option (or 
!!                     before the first `--right` option) up until the next 
!!                     `--right` option are taken to be in the left set of 
!!                     source files.  May be specified multiple times.
!!
!! -r or --right       Source file specifications following this option up 
!!                     until the next `--left` option are taken to be in the 
!!                     right set of source files.  May be specified multiple 
!!                     times.
!!
!! --list[:] file      Specify a list file - each record  from the given file 
!!                     will be added (in addition to any source file 
!!                     specifications provided on the command line) to the 
!!                     list of source filespecifications for the prevailing 
!!                     set (as indicated by `--left` and `--right`) to be 
!!                     processed.  May be specified multiple times.
!!
!! source-file-specs is a list of the names of the Fortran source files to 
!! parse.
!!
!! If neither `--left` or `--right` is specified, then there must be only two 
!! source-file-specs that each evaluate to a single source filename, the first
!! filename becomes the left source set and the second filename becomes the 
!! right file set.  Alternatively, there can be two --list options - the first 
!! specifies the files for the left set, the second for the right set.
!!
!! For most platforms a source file specification is the same as the name 
!! of a source file.  Some platforms may offer the ability for a source file 
!! specification to contain wildcards that may expand out to zero or more 
!! source file names.  This requires processor capability that is not 
!! described in the F2003 standard and which is not included in default 
!! builds.
!!
!! Differencing is not sensitive to:
!! - source form and source form presentation aspects, such as the location 
!!   of continuations in particular statements.
!! - comments.
!! - the case of keywords or names.
!! - the order of program units or internal or module subprograms.
!!
!! As the differencing looks at the semantics of the source code, it requires 
!! the source code to be standard conforming and free of syntax errors to 
!! the degree sufficient for the program to understand the intended semantics.  
!! This particularly includes structural aspects of the source, such as 
!! matching beginning and end statements for any constructs.
!!
!! Differences are reported to the console.  Errors encoutered during 
!! differencing are reported to the error unit.
!!
!! Each differences is typically reported using three records (lines):
!! - the relevant location in the left file set.
!! - the relevant location in the right file set.
!! - a description of the difference, with two leading blanks.
!! If there is no relevant location then the location records will be empty.
!!
!! STOP codes (which may also be the program's exit code):
!!
!! - 0, or no code:   Differencing completed successfully and no differences 
!!                    were detected.
!!
!! - 1:               Differencing completed successfully and semantic 
!!                    differences were detected.
!!
!! - 2:               Differencing analysis commenced, but with errors.
!!                    (I know what you want me to do, but I couldn't do it.)
!!
!! - 3:               There was a problem with the command line arguments.  
!!                    (I haven't got a clue what you want to do.)
!!
!! Program unit notes
!! ==================
!!
!! Differencing is carried out on the statement tree and hence requires a 
!! successful build of the statement tree.  For significant tree nodes 
!! (mostly program units and subprograms) the differencing is aware of the 
!! structure of the tree, for lower nodes (particularly the nodes for 
!! executable constructs) the differencing is done at a statement 
!! level - with the list of statements generated by flattening the tree.
!!
!! The main program processes command line options (including assembly of 
!! the source file spec lists for the left and right sets) and reports 
!! obvious errors before handling over to the Execute procedure in the 
!! DiffImplementation module.

PROGRAM FF08Diff
  
  USE CmdLine
  USE DiffImplementation
  USE FileUtilities
  USE Strings
  USE Version
  
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT, ERROR_UNIT
  
  IMPLICIT NONE
  
  !-----------------------------------------------------------------------------
  ! Local constants
  
  ! Name of this program - for the --version option.
  CHARACTER(*), PARAMETER :: program_name  &
      = 'FF08Diff'
  
  !-----------------------------------------------------------------------------
  ! Local variables
  
  ! Command line option description and parsing results.
  !
  ! In order: --help, --version, --left, --right, --list, --show-warnings
  TYPE(CmdLineOption) :: cmd_line_options(6)
  
  ! List of non-option arguments.
  TYPE(String), ALLOCATABLE :: arguments(:)
  
  ! Positions that correspond to each non-option argument.
  INTEGER, ALLOCATABLE :: positions(:)
  
  ! List of file specifications for the left set.
  TYPE(String), ALLOCATABLE :: left_specs(:)
  
  ! List of file specifications for the right set.
  TYPE(String), ALLOCATABLE :: right_specs(:)
  
  ! Error message
  CHARACTER(:), ALLOCATABLE :: msg
  
  INTEGER :: stat             ! Error code for ParseCmdLine call.
  INTEGER :: stop_code        ! Stop code from procedure calls
  LOGICAL :: has_left         ! Flag to indicate that --left was specified.
  LOGICAL :: has_right        ! Flag to indicate that --right was specified.
  INTEGER :: iarg             ! Argument index.
  LOGICAL :: show_warnings    ! Flag to indicate --show-warnings was specified.
  
  !*****************************************************************************
  
  !-----------------------------------------------------------------------------
  ! Set up and process command line options.
  
  cmd_line_options(1) = CmdLineOption(  &
      LONG_NAME='help',  &
      CHAR_NAME='?',  &
      DESCRIPTION='Display command line and program usage help, then exit.' )
  
  cmd_line_options(2) = CmdLineOption(  &
      LONG_NAME='version',  &
      DESCRIPTION='Display program version information, then exit.' )
  
  cmd_line_options(3) = CmdLineOption(  &
      LONG_NAME='left',  &
      CHAR_NAME='l',  &
      DESCRIPTION='Source file specifications following this option &
        &(or before the first `--right` option) up until the next `--right` &
        &option are taken to be in the left set of source files.',  &
      CAN_REPEAT=.TRUE. )
  
  cmd_line_options(4) = CmdLineOption(  &
      LONG_NAME='right',  &
      CHAR_NAME='r',  &
      DESCRIPTION='Source file specifications following this option &
        &up until the next `--left` option are taken to be in the &
        &right set of source files.',  &
      CAN_REPEAT=.TRUE. )
  
  cmd_line_options(5) = CmdLineOption(  &
      LONG_NAME='list',  &
      DESCRIPTION='Specify a list file - each line from the given file will &
                  &be added (in addition to any source file specifications &
                  &provided on the command line) to the list of source file &
                  &specifications for the prevailing set (as indicated by &
                  &`--left` and `--right`) to be processed.  May be specified &
                  &multiple times.',  &
      OPTION_TYPE=ioptArg,  &
      CAN_REPEAT=.TRUE. )
  
  cmd_line_options(6) = CmdLineOption(  &
      LONG_NAME='show-warnings',  &
      DESCRIPTION='Show warnings generated during the processing of each &
                  &file.  Warnings typically relate to violations of the &
                  &language standard.' )
  
  CALL ParseCmdLine(cmd_line_options, arguments, stat, msg, positions)
  
  IF (stat /= 0) THEN
    WRITE (ERROR_UNIT, "('Error parsing command line:',A)") msg
    CALL usage_message(OUTPUT_UNIT, cmd_line_options)
    STOP 3
  END IF
  
  ! Check for the --help (or -?) option in priority to all others.
  !
  ! If no arguments or options are provided (i.e. no command line 
  ! arguments) then we have nothing to do.  Interpret that as 
  ! a request for help as well.
  IF ( (cmd_line_options(1)%PresentCount > 0)  &
      .OR. (COMMAND_ARGUMENT_COUNT() == 0) ) THEN
    CALL usage_message(OUTPUT_UNIT, cmd_line_options)
    STOP
  END IF
  
  ! Check for the --version option.
  IF (cmd_line_options(2)%PresentCount > 0) THEN
    CALL VersionMessage(program_name)
    STOP
  END IF
  
  has_left = cmd_line_options(3)%PresentCount /= 0
  has_right = cmd_line_options(4)%PresentCount /= 0
  
  IF (has_left .OR. has_right) THEN
    ! Distribute arguments to left and right.
    DO iarg = 1, SIZE(arguments)
      IF (to_right(  &
          positions(iarg),  &
          cmd_line_options(3)%Positions,  &
          cmd_line_options(4)%Positions )) THEN
        CALL Append(right_specs, arguments(iarg)%item)
      ELSE
        CALL Append(left_specs, arguments(iarg)%item)
      END IF
    END DO
    
    ! Distribute list options to the left and right.
    ! If there are any list files specified then expand the list of files 
    ! to accomodate their contents.
    DO iarg = 1, cmd_line_options(5)%PresentCount
      IF (to_right(  &
          cmd_line_options(5)%Positions(iarg),  &
          cmd_line_options(3)%Positions,  &
          cmd_line_options(4)%Positions )) THEN
        CALL AddListFile(  &
            right_specs,  &
            cmd_line_options(5)%Argument(iarg)%item,  &
            ERROR_UNIT,  &
            stop_code )
        IF (stop_code /= 0) CALL do_stop
      ELSE
        CALL AddListFile(  &
            left_specs,  &
            cmd_line_options(5)%Argument(iarg)%item,  &
            ERROR_UNIT,  &
            stop_code )
        IF (stop_code /= 0) CALL do_stop
      END IF
    END DO
  ELSE
    IF ( (SIZE(arguments) == 2)  &
        .AND. (cmd_line_options(5)%PresentCount == 0) ) THEN
      left_specs = arguments(1:1)
      right_specs = arguments(2:2)
    ELSE IF ( (SIZE(arguments) == 0)  &
        .AND. (cmd_line_options(5)%PresentCount == 2) ) THEN
      CALL AddListFile(  &
          left_specs,  &
          cmd_line_options(5)%Argument(1)%item,  &
          ERROR_UNIT,  &
          stop_code )
      IF (stop_code /= 0) CALL do_stop
      CALL AddListFile(  &
          right_specs,  &
          cmd_line_options(5)%Argument(2)%item,  &
          ERROR_UNIT,  &
          stop_code )
      IF (stop_code /= 0) CALL do_stop
    ELSE
      WRITE ( ERROR_UNIT, "('If neither --left or --right is specified, then &
          &either two and only two file-specs must be provided or two and &
          &only two --list options provided, but not both.')" )
      STOP 3
    END IF
  END IF
  
  show_warnings = cmd_line_options(6)%PresentCount /= 0
  
  !-----------------------------------------------------------------------------
  
  CALL Execute(  &
      left_specs,  &
      right_specs,  &
      OUTPUT_UNIT,  &
      ERROR_UNIT,  &
      show_warnings,  &
      stop_code )
  
  !-----------------------------------------------------------------------------
  ! Cleanup and shut down.
  
  CALL do_stop
  
CONTAINS
  
  ! F2003 doesn't allow an expression as a stop-code so this is a work around.
  SUBROUTINE do_stop
    SELECT CASE (stop_code)
    CASE (0)   ! Fall through to end statement.
    CASE (1) ; STOP 1
    CASE (2) ; STOP 2
    CASE DEFAULT;  STOP 3
    END SELECT
  END SUBROUTINE do_stop
  
  !*****************************************************************************
  !!
  !> Determine whether a particular position corresponds to the left 
  !! set or the right set.
  !!
  !! @param[in]     pos               The position of interest.
  !!
  !! @param[in]     left_positions    Positions of the --left options.
  !!
  !! @param[in]     right_positions   Positions of the --right options.
  
  FUNCTION to_right(pos, left_positions, right_positions)
    
    !---------------------------------------------------------------------------
    ! Characteristics
    
    INTEGER, INTENT(IN) :: pos
    INTEGER, INTENT(IN) :: left_positions(:)
    INTEGER, INTENT(IN) :: right_positions(:)
    
    ! Function result.
    LOGICAL :: to_right
    
    !---------------------------------------------------------------------------
    ! Local variables
    
    INTEGER :: ip             ! Argument or option position.
    INTEGER :: lpos_idx       ! Index into the positions of the --left option.
    INTEGER :: rpos_idx       ! Index into the positions of the --right option.
    
    !***************************************************************************
    
    lpos_idx = 1
    rpos_idx = 1
    to_right = .FALSE.        ! Start with left.
    
    DO ip = 1, pos - 1
      ! A left or right option cannot occupy the same position, so if we 
      ! match one we don't have to test the other.
      IF (to_right) THEN
        IF (safe_match(left_positions, lpos_idx, ip)) THEN
          to_right = .FALSE.
          lpos_idx = lpos_idx + 1
        ELSE IF (safe_match(right_positions, rpos_idx, ip)) THEN
          ! Situation such as --right --right --right...
          rpos_idx = rpos_idx + 1
        END IF
      ELSE
        IF (safe_match(right_positions, rpos_idx, ip)) THEN
          to_right = .TRUE.
          rpos_idx = rpos_idx + 1
        ELSE IF (safe_match(left_positions, lpos_idx, ip)) THEN
          ! Situation such as --left --left --left...
          lpos_idx = lpos_idx + 1
        END IF
      END IF
    END DO
    
  END FUNCTION to_right
  
  
  !*****************************************************************************
  !!
  !> Performs a "safe" comparison with the current position and the next 
  !! position of a particular option.
  !!
  !! @param[in]     positions         The positions for the particular option.
  !!
  !! @param[in]     idx               Index of the last element in positions 
  !! considered.  This can be out of range of @a positions if all elements 
  !! have been considered.
  !!
  !! @param[in]     current           Position being currently considered.
  !!
  !! @returns true if the current position is what is indicated by the 
  !! @a idx element in @a positions.
  
  FUNCTION safe_match(positions, idx, current)
    
    !---------------------------------------------------------------------------
    ! Characteristics
    
    INTEGER, INTENT(IN) :: positions(:)
    INTEGER, INTENT(IN) :: idx
    INTEGER, INTENT(IN) :: current
    
    ! Function result.
    LOGICAL :: safe_match
    
    !***************************************************************************
    
    safe_match = .FALSE.
    
    ! If idx is out of range, then we have no match.
    IF (idx < 1) RETURN
    IF (idx > SIZE(positions)) RETURN
    
    safe_match = positions(idx) == current
    
  END FUNCTION safe_match
  
  
  !*****************************************************************************
  !!
  !> Prints the command line usage message for the program.  This is 
  !! intended as the handler for '--help' or similar.
  !!
  !! @param[in]     out_unit          Logical unit connected for formatted 
  !! output to receieve the usage message.
  !!
  !! @param[in]     cmd_line_options  Command line options defined for the 
  !! program.
  !!
  !! Try and keep this consistent with the description in the lead-in 
  !! comments for the main program, or users and (more importantly) 
  !! programmers will get confused.
  
  SUBROUTINE usage_message(out_unit, cmd_line_options)
    
    USE CmdLine
    
    !---------------------------------------------------------------------------
    ! Arguments
    
    INTEGER, INTENT(IN) :: out_unit
    TYPE(CmdLineOption), INTENT(IN) :: cmd_line_options(:)
    
    !---------------------------------------------------------------------------
    ! Local constants
    
    ! Format specification for a lines worth of message.
    CHARACTER(*), PARAMETER :: fmt_a = "(A)"
    
    !---------------------------------------------------------------------------
    ! Local variables
    
    ! First argument on command line, which is normally the program name.
    CHARACTER(:), ALLOCATABLE :: local_program_name
    
    INTEGER :: stat           ! Error code for command line argument query.
    
    !***************************************************************************
    
    WRITE (out_unit, fmt_a) 'Display the differences between two sets of &
        &Fortran source files.'
    WRITE (out_unit, "()")
    
    ! Use actual program name in description, in case we've been renamed.
    CALL GetCmdLineArgument(0, local_program_name, stat)
    IF (stat /= 0) local_program_name = program_name
    
    WRITE (out_unit, fmt_a) 'Usage: ' // local_program_name  &
        // ' [options] source-file-specs... [--right source-file-specs]'
    WRITE (out_unit, "()")
    WRITE (out_unit, fmt_a) 'Valid options are:'
    WRITE (out_unit, "()")
    
    CALL WriteUsageMessage(cmd_line_options, out_unit)
    
    ! Short and simple - we won't elaborate on names versus spec's here.  We 
    ! rely on format reversion to do multiple records for each 80 character 
    ! (approx) line.
    WRITE (out_unit, fmt_a)  &
!        1234567890123456798012345678901234567890
        'source-file-specs is a list of the names&
        & of the Fortran source files to parse.'
    
    WRITE (out_unit, fmt_a) ''
    
    WRITE (out_unit, fmt_a)  &
!        1234567890123456798012345678901234567890
        'If neither `--left` or `--right` is spec&
        &ified, then there must be only two', &
        'source-file-specs that each evaluate to &
        &a single source filename, the first',  &
        'filename becomes the left source set and&
        & the second filename becomes the right', &
        'file set.  Alternatively, there can be t&
        &wo --list options - the first specifies',  &
        'the files for the left set, the second f&
        &or the right set.'
    
  END SUBROUTINE usage_message
  
END PROGRAM FF08Diff
