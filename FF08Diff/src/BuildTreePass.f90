! $Id: BuildTreePass.f90 2947 2019-09-25 21:05:13Z ian $
! ff08 source code copyright 2012 M.E.G.M.S.  See LICENCE.txt for licence.
!> @file
!! Defines the BuildTreePass module.


!*******************************************************************************
!!
!> Routines to execute the Build Tree pass of compilation, where we fold a 
!! file up into statement tree nodes (StNode's).
!!
!! The idea of this pass is that we collect all the relevant statements 
!! for an identifiable scope together.  If necessary, then we can come back 
!! at a later stage and compile bits of the program selectively.
!!
!! During this pass no resolution of variables occurs, and some statements 
!! might be classified incorrectly.
!!
!! This can be the first high level pass called on a source file though a 
!! dependency pass may have been called previously.
!!
!! In the normal sequence of compilation the next pass to be called would 
!! be the Advertise pass.
!!
!! Errors that may be generated during the Build Tree pass relate to the 
!! syntax and structure of the code (statements in the wrong place, 
!! source code blocks not nested or terminated correctly, etc).
!!
!! The results of this pass on its own could be of use to text editors 
!! that need to know the structure of the source for outlining, etc.

MODULE BuildTreePass
  
  USE Errors
  USE StNodes
  
  IMPLICIT NONE
  
  PRIVATE
  
  !-----------------------------------------------------------------------------
  ! Expose module procedures and interfaces
  
  PUBLIC :: DoBuildTreePass
  PUBLIC :: DoBuildTreePassCheck
  
  !-----------------------------------------------------------------------------
  ! Interfaces
  
  !> Execute the build tree pass, which folds statements up into their
  !! logical groupings.
  INTERFACE DoBuildTreePass
    MODULE PROCEDURE DoBuildTreePass_with_statements
    MODULE PROCEDURE DoBuildTreePass_from_scratch
    MODULE PROCEDURE DoBuildTreePass_with_form
  END INTERFACE DoBuildTreePass
  
  !> Type for implementing the check traversal.
  TYPE, EXTENDS(StNodeQueryVisitor) :: check_query
    !> The list of errors that results from checking.
    TYPE(Error), ALLOCATABLE :: err_list(:)
  CONTAINS
    PROCEDURE :: ExecuteNode => check_ExecuteNode
    PROCEDURE :: ExecuteStmt => check_ExecuteStmt
  END TYPE check_query
  
CONTAINS
  
  !*****************************************************************************
  !!
  !> Procedure to build the tree when you already have the statement data 
  !! (perhaps from a previous dependency pass).
  !!
  !! @param[in,out] statements        Statement data generated by a 
  !! previous pass.
  !!
  !! @param[out]    base              The base (root) of the statement 
  !! tree that represents the entire program (this could be multiple 
  !! program units).
  !!
  !! @param[out]    err_list          List of errors.
  !!
  !! @param[in]     ensure_unique     Optional flag to specify that the 
  !! uniqueness of the child program units will be guaranteed or the tree 
  !! build must fail.
  !!
  !! After the call there will be no useful information in @a stmts.
  
  SUBROUTINE DoBuildTreePass_with_statements( stmts, base, err_list,  &
      ensure_unique )
    
    USE BaseStNodes
    USE Classifier
    USE Errors
    USE ErrorCodes
    USE ErrorLevels
    USE StNodes
    USE Statements
    USE StatementData
    
    !---------------------------------------------------------------------------
    ! Arguments
    
    TYPE(StData), INTENT(INOUT) :: stmts(:)
    TYPE(BaseStNode), INTENT(OUT), POINTER :: base
    TYPE(Error), INTENT(OUT), ALLOCATABLE :: err_list(:)
    LOGICAL, INTENT(IN), OPTIONAL :: ensure_unique
    
    !---------------------------------------------------------------------------
    ! Local variables
    
    INTEGER :: i              ! Statement index.
    
    ! Current (before BuildTree) tip of the statement tree.  The current 
    ! tip is what is called in order to handle the next statement.
    CLASS(StNode), POINTER :: tip
    
    ! New tip (after BuiltTree) of the statement tree.  This could be a 
    ! parent node of the current tip, a child node of the current tip, 
    ! or in many cases, the same node as the current tip.
    CLASS(StNode), POINTER :: new_tip
    
    ! List of errors for child procedure calls.
    TYPE(Error), ALLOCATABLE :: sub_err_list(:)
    
    !***************************************************************************
    
    ALLOCATE(BaseStNode:: base)
    IF (PRESENT(ensure_unique)) base%ensure_unique = ensure_unique
    
    tip => base
    
    DO i = 1, SIZE(stmts)
      
      ! We ignore the classification that we've already done as the context
      ! may change it.
      CALL Classify(stmts(i)%tlist, GetParts(tip), stmts(i)%ist)
      
      ! No point trying to build a tree with statements that cannot be 
      ! classified.
      IF (stmts(i)%ist == istUnclassified) THEN
        CALL Add( err_list,  &
            CODE=errUnclassifiedStatement,  &
            LOCATION=QueryLocation(stmts(i)%tlist(1)),  &
            MSG='Unclassifiable statement.' )
        CYCLE
      END IF
      
      CALL tip%BuildTree(stmts(i), new_tip, sub_err_list)
      CALL Add(err_list, sub_err_list)
      IF (Failure(sub_err_list)) RETURN
      
      tip => new_tip
      
    END DO
    
  END SUBROUTINE DoBuildTreePass_with_statements
  
  
  !*****************************************************************************
  !!
  !> Procedure to build the tree when all you have is a source file.
  !!
  !! @param[in]     host              Object that describes host behaviour.
  !!
  !! @param[in]     filename          Name of the soucre file to be processed.
  !!
  !! @param[out]    base              The base (root) of the statement 
  !! tree that represents the entire program (this could be multiple 
  !! program units).  If the file could not be read this will be 
  !! dissociated, otherwise it is allocated and should be deallocated 
  !! (eventually) by the caller.
  !!
  !! @param[out]    err_list          List of errors.
  !!
  !! @param[in]     ensure_unique     Optional flag to specify that the 
  !! uniqueness of the child program units will be guaranteed or the tree 
  !! build must fail.
  !!
  !! @todo Consider whether the appropriate entry point for this procedure 
  !! is the case where the client actually already has a Source object.
  
  SUBROUTINE DoBuildTreePass_from_scratch( host, filename,  &
      base, err_list, ensure_unique )
    
    USE BaseStNodes
    USE CompilerHosts
    USE Errors
    USE Scanner
    USE Sources
    USE Statements
    USE StatementData
    USE StNodes
    USE SyntaxParts
    USE Tokens
    
    !---------------------------------------------------------------------------
    ! Arguments
    
    CLASS(CompilerHost), INTENT(IN) :: host
    CHARACTER(*), INTENT(IN) :: filename
    TYPE(BaseStNode), INTENT(OUT), POINTER :: base
    TYPE(Error), INTENT(OUT), ALLOCATABLE :: err_list(:)
    LOGICAL, INTENT(IN), OPTIONAL :: ensure_unique
    
    !---------------------------------------------------------------------------
    ! Local variables
    
    ! Error list for child procedure calls.
    TYPE(Error), ALLOCATABLE :: sub_err_list(:)
    
    ! Source form relevant to the file.
    CLASS(SourceForm), ALLOCATABLE :: form
    
    !***************************************************************************
    
    ALLOCATE(err_list(0))
    
    !---------------------------------------------------------------------------
    
    CALL host%OpenSourceForm(filename, form, sub_err_list)
    CALL Add(err_list, sub_err_list)
    ! Not much point continuing if we couldn't open the file.
    IF (Failure(sub_err_list)) THEN
      base => NULL()
      RETURN
    END IF
    
    CALL DoBuildTreePass_with_form(  &
        host,  &
        form,  &
        base,  &
        sub_err_list,  &
        ensure_unique )
    CALL Add(err_list, sub_err_list)
    
  END SUBROUTINE DoBuildTreePass_from_scratch
  
  
  !*****************************************************************************
  !!
  !> Procedure to build the tree when all you have is a source file.
  !!
  !! @param[in]     host              Object that describes host behaviour.  
  !! This is used for opening any referenced INCLUDE files.
  !!
  !! @param[in]     form              Source form supplying the source.
  !!
  !! @param[out]    base              The base (root) of the statement 
  !! tree that represents the entire program (this could be multiple 
  !! program units).
  !!
  !! @param[out]    err_list          List of errors.
  !!
  !! @param[in]     ensure_unique     Optional flag to specify that the 
  !! uniqueness of the child program units will be guaranteed or the tree 
  !! build must fail.
  !!
  !! @todo Consider whether the appropriate entry point for this procedure 
  !! is the case where the client actually already has a Source object.
  
  SUBROUTINE DoBuildTreePass_with_form( host, form,  &
      base, err_list, ensure_unique )
    
    USE BaseStNodes
    USE Classifier
    USE CompilerHosts
    USE Errors
    USE ErrorCodes
    USE ErrorLevels
    USE IncludeLines
    USE LabelsUtils
    USE Scanner
    USE Sources
    USE Statements
    USE StatementData
    USE StNodes
    USE SyntaxParts
    USE Tokens
    
    !---------------------------------------------------------------------------
    ! Arguments
    
    CLASS(CompilerHost), INTENT(IN) :: host
    CLASS(SourceForm), INTENT(INOUT), TARGET :: form
    TYPE(BaseStNode), INTENT(OUT), POINTER :: base
    TYPE(Error), INTENT(OUT), ALLOCATABLE :: err_list(:)
    LOGICAL, INTENT(IN), OPTIONAL :: ensure_unique
    
    !---------------------------------------------------------------------------
    ! Local constants
    
    ! Maximum number of errors before the pass is abandoned.
    INTEGER, PARAMETER :: max_errors = 20
    
    !---------------------------------------------------------------------------
    ! Local variables
    
    ! Local type for a vector of source form objects.
    TYPE form_stack_t
      CLASS(SourceForm), ALLOCATABLE :: store
      CLASS(SourceForm), POINTER :: item
    END TYPE form_stack_t
    
    ! A stack of source form objects - the first element is for the given 
    ! file and subsequent elements are for INCLUDE'd files.
    TYPE(form_stack_t), ALLOCATABLE, TARGET :: form_stack(:)
    
    ! Error list for child procedure calls.
    TYPE(Error), ALLOCATABLE :: sub_err_list(:)
    
    ! Current tip of the statement tree node.
    CLASS(StNode), POINTER :: tip
    
    ! Syntax part stack.
    INTEGER, ALLOCATABLE :: part_stack(:)
    
    ! Tokens for the current statement.
    TYPE(Token), ALLOCATABLE :: tlist(:)
    
    INTEGER :: error_count    ! Number of errors so far.
    LOGICAL :: is_include     ! INCLUDE line flag.
    INTEGER :: ist            ! Current statement classification.
    
    ! Label (if any) of the current statement.
    TYPE(Label), ALLOCATABLE :: statement_label
    
    ! Pointer to the parent source object of an INCLUDE'd file.
    CLASS(Source), POINTER :: parent_source
    
    ! Pointer to the source object for the included file.
    CLASS(Source), POINTER :: inc_source
    
    !***************************************************************************
    
    error_count = 0
    
    ALLOCATE(form_stack(1))
    form_stack(1)%item => form
    
    ALLOCATE(BaseStNode:: base)
    IF (PRESENT(ensure_unique)) base%ensure_unique = ensure_unique
    tip => base
    
    ! We only exit this loop via EXIT if we run out of source.  If we have 
    ! a fatal error or exceed the permissible error count we just RETURN.
    DO
      part_stack = GetParts(tip)
      
      !-------------------------------------------------------------------------
      ! Get a statement from the source form at the top of the stack.
      
      CALL form_stack(SIZE(form_stack))%item%GetStatement(  &
          part_stack,  &
          sub_err_list,  &
          tlist,  &
          statement_label )
      CALL Add(err_list, sub_err_list)
      IF (Fatal(sub_err_list)) RETURN
      error_count = error_count + COUNT(sub_err_list >= errLevelError)
      IF (error_count > max_errors) RETURN
      ! If we failed to get a statement then don't try and classify it.
      IF (Failure(sub_err_list)) CYCLE
      
      ! No token in a statement means end-of-file.
      IF (SIZE(tlist) == 0) THEN
        ! Close the file.
        CALL form_stack(SIZE(form_stack))%item%GetSource(inc_source)
        CALL inc_source%Reset()
        IF (SIZE(form_stack) > 1) THEN
          CALL shrink_stack
          CYCLE
        ELSE
          EXIT
        END IF
      END IF
      
      !-------------------------------------------------------------------------
      ! Test to see if the statement looks like an include line.
      
      CALL CheckInclude(tlist, statement_label, is_include, sub_err_list)
      CALL Add(err_list, sub_err_list)
      IF (Fatal(sub_err_list)) RETURN
      error_count = error_count + COUNT(sub_err_list >= errLevelError)
      IF (error_count > max_errors) RETURN
      IF (Failure(sub_err_list)) CYCLE
      
      IF (is_include) THEN
        !-----------------------------------------------------------------------
        ! Process an include line by pushing a new source form to the top of
        ! the stack
        
        CALL form_stack(SIZE(form_stack))%item%GetSource(parent_source)
        CALL grow_stack
        CALL host%OpenIncludeFile(  &
            tlist(2),  &
            parent_source,  &
            inc_source,  &
            sub_err_list )
        CALL Add(err_list, sub_err_list)
        IF (Failure(sub_err_list)) RETURN
        error_count = error_count + COUNT(sub_err_list >= errLevelError)
        
        CALL form_stack(SIZE(form_stack) - 1)%item%Clone( inc_source,  &
            form_stack(SIZE(form_stack))%store )
        form_stack(SIZE(form_stack))%item => form_stack(SIZE(form_stack))%store
        CYCLE
        
      END IF
      
      !-------------------------------------------------------------------------
      ! Work out what sort of statement we got.  This also tests for include
      ! lines.
      
      CALL Classify(tlist, part_stack, ist)
      
      ! No point trying to build a tree with statements that cannot be 
      ! classified.
      IF (ist == istUnclassified) THEN
        CALL Add( err_list,  &
            CODE=errUnclassifiedStatement,  &
            LOCATION=QueryLocation(tlist(1)),  &
            MSG='Unclassifiable statement.' )
        error_count = error_count + 1
        IF (error_count > max_errors) RETURN
        CYCLE
      END IF
      
      !-------------------------------------------------------------------------
      ! Incorporate the statement into the statement tree.
      
      ! This call updates the statement tip pointer.
      CALL BuildTree(tip, ist, statement_label, tlist, sub_err_list)
      CALL Add(err_list, sub_err_list)
      IF (Fatal(sub_err_list)) RETURN
      error_count = error_count + COUNT(sub_err_list >= errLevelError)
      IF (error_count > max_errors) RETURN
    END DO
    
    ! Here only if we run out of source.
    
    ! We've run out of source.  Terminate whatever is the current tip.
    CALL TerminateTree(base, tip, sub_err_list)
    CALL Add(err_list, sub_err_list)
    
  CONTAINS
    
    !***************************************************************************
    !
    ! Grow the stack of source form objects, presumably in response to 
    ! an INCLUDE line.
    !
    ! Accesses the form_stack variable by host association.
    
    SUBROUTINE grow_stack
      ! Temporary for growing the existing form stack.
      TYPE(form_stack_t), ALLOCATABLE :: tmp(:)
      INTEGER :: i            ! Form stack index.
      !*************************************************************************
      ALLOCATE(tmp(SIZE(form_stack) + 1))
      DO i = 1, SIZE(form_stack)
        tmp(i)%item => form_stack(i)%item
      END DO
      
      CALL MOVE_ALLOC(tmp, form_stack)
    END SUBROUTINE grow_stack
    
    !***************************************************************************
    !
    ! Shrink the stack of source form objects, presumably as processing of 
    ! an INCLUDE'd file completes.
    !
    ! Accesses the form_stack variable by host association.
    
    SUBROUTINE shrink_stack
      ! Temporary for growing the existing form stack.
      TYPE(form_stack_t), ALLOCATABLE :: tmp(:)
      INTEGER :: i            ! Form stack index.
      !*************************************************************************
      ALLOCATE(tmp(SIZE(form_stack) - 1))
      DO i = 1, SIZE(tmp)
        tmp(i)%item => form_stack(i)%item
      END DO
      
      CALL MOVE_ALLOC(tmp, form_stack)
    END SUBROUTINE shrink_stack
    
  END SUBROUTINE DoBuildTreePass_with_form
  
  
  !-----------------------------------------------------------------------------
  !-----------------------------------------------------------------------------
  !
  ! Procedures for the Check subpass of the BuildTree pass.
  
  
  !*****************************************************************************
  !!
  !> Performs the check subpass
  !!
  !! @param[in]     st                The statement tree node being traversed.
  !!
  !! @param[out]    err_list          List of errors.
  
  SUBROUTINE DoBuildTreePassCheck(st, err_list)
    
    USE BaseStNodes
    
    !---------------------------------------------------------------------------
    ! Arguments
    
    CLASS(StNode), INTENT(IN), TARGET :: st
    TYPE(Error), INTENT(OUT), ALLOCATABLE :: err_list(:)
    
    !---------------------------------------------------------------------------
    ! Local variables
    
    TYPE(check_query) :: visitor
    
    !***************************************************************************
    
    ALLOCATE(visitor%err_list(0))
    
    CALL st%Query(visitor)
    
    CALL MOVE_ALLOC(visitor%err_list, err_list)
    
  END SUBROUTINE DoBuildTreePassCheck
  
  
  !*****************************************************************************
  !!
  !> Implementation of check_query%ExecuteNode - invokes the Check binding 
  !! on each node.
  !!
  !! @param[in,out] visitor           The object executing the traversal.
  !!
  !! @param[in]     st                The statement tree node being traversed.
  
  SUBROUTINE check_ExecuteNode(visitor, st)
    
    !---------------------------------------------------------------------------
    ! Arguments
    
    CLASS(check_query), INTENT(INOUT) :: visitor
    CLASS(StNode), INTENT(IN), TARGET :: st
    
    !---------------------------------------------------------------------------
    ! Local variables
    
    ! Error list for Check call.
    TYPE(Error), ALLOCATABLE :: sub_err_list(:)
    
    !***************************************************************************
    
    CALL st%Check(sub_err_list)
    CALL Add(visitor%err_list, sub_err_list)
    
  END SUBROUTINE check_ExecuteNode
  
  
  !*****************************************************************************
  !!
  !> Implementation of check_query%ExecuteNode - invokes the Check binding 
  !! on each statement of each node.
  !!
  !! @param[in,out] visitor           The object executing the traversal.
  !!
  !! @param[in]     st                The statement tree node that holds the 
  !! statement.
  !!
  !! @param[in]     stmt              The statement being traversed.
  !!
  !! Does nothing.
  
  SUBROUTINE check_ExecuteStmt(visitor, parent, stmt)
    
    USE StatementData
    
    !---------------------------------------------------------------------------
    ! Arguments
    
    CLASS(check_query), INTENT(INOUT) :: visitor
    CLASS(StNode), INTENT(IN), TARGET :: parent
    TYPE(StData), INTENT(IN) :: stmt
    
    !***************************************************************************
    
  END SUBROUTINE check_ExecuteStmt
  
END MODULE BuildTreePass
