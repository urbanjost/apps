." Text automatically generated by txt2man
.TH "luhn_checksum" "3m_hashkeys" "March 13, 2022" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." set smaller margin and spacing options
.ta T 0.2i
.nr IN 0.2i
." -----------------------------------------------------------------
.SH NAME
\fBluhn_checksum\fP(3f) - [M_hashkeys] Luhn checksum algorithm applied to a string of numeric values

.SH DESCRIPTION

The Luhn algorithm or Luhn formula, also known as the "modulus 10" or
"mod 10" algorithm, named after IBM scientist Hans Peter Luhn, is a simple
checksum formula used to validate a variety of identification numbers
such as credit card numbers, IMEI numbers, National Provider Identifier
numbers in the United States, Canadian Social Insurance Numbers, Israel
ID Numbers, Greek Social Security Numbers, and survey codes appearing on
McDonald's, Taco Bell, and Tractor Supply Co. receipts. It was created by
IBM scientist Hans Peter Luhn and described in U.S. Patent No. 2,950,048,
filed on January 6, 1954, and granted on August 23, 1960.
.PP
The algorithm is in the public domain and is in wide use today. It
is specified in ISO/IEC 7812-1.[1] It is not intended to be a
cryptographically secure hash function; it was designed to protect against
accidental errors, not malicious attacks. Most credit cards and many
government identification numbers use the algorithm as a simple method of
distinguishing valid numbers from mistyped or otherwise incorrect numbers.
.PP
The formula verifies a number against its included check digit, which
is usually appended to a partial account number to generate the full
account number. This number must pass the following test:
.IP 1. 4
From the rightmost digit, which is the check digit, and moving left,
double the value of every second digit. The check digit is not doubled;
the first digit doubled is immediately to the left of the check digit. If
the result of this doubling operation is greater than 9 (e.g., 8 × 2 =
16), then add the digits of the result (e.g., 16: 1 + 6 = 7, 18: 1 + 8 =
.RS
.IP 9) 4
or, alternatively, the same final result can be found by subtracting
9 from that result (e.g., 16: 16 − 9 = 7, 18: 18 − 9 = 9).
.RE
.IP 2. 4
Take the sum of all the digits.
.IP 3. 4
If the total modulo 10 is equal to 0 (if the total ends in zero) then
the number is valid according to the Luhn formula; else it is not valid.
.PP
Assume an example of an account number "7992739871" that will have a
check digit added, making it of the form 7992739871x:
.PP
Account number
.RS
.TP
.B 7
9  9  2  7  3  9  8  7  1  x
.RE
.PP
Double every other
.RS
.TP
.B 7
18  9  4  7  6  9  16  7  2  x
.RE
.PP
Sum digits
.RS
.TP
.B 7
9  9  4  7  6  9  7  7  2  x
.RE
.PP
The sum of all the digits in the third row is 67+x.
.PP
The check digit (x) is obtained by computing the sum of the non-check
digits then computing 9 times that value modulo 10 (in equation form,
((67 × 9) mod 10)). In algorithm form:
.RS
.IP 1. 4
Compute the sum of the non-check digits (67).
.IP 2. 4
Multiply by 9 (603).
.IP 3. 4
The units digit (3) is the check digit. Thus, x=3.
.RE
.PP
(Alternative method) The check digit (x) is obtained by computing the sum
of the other digits (third row) then subtracting the units digit from 10
(67 => Units digit 7; 10 − 7 = check digit 3). In algorithm form:
.RS
.IP 1. 4
Compute the sum of the non-check digits (67).
.IP 2. 4
Take the units digit (7).
.IP 3. 4
Subtract the units digit from 10.
.IP 4. 4
The result (3) is the check digit. In case the sum of digits ends in
0 then 0 is the check digit.
.RE
.PP
This makes the full account number read 79927398713.
.PP
Each of the numbers 79927398710, 79927398711, 79927398712, 79927398713,
79927398714, 79927398715, 79927398716, 79927398717, 79927398718,
79927398719 can be validated as follows.
.RS
.IP 1. 4
Double every second digit, from the rightmost: (1×2) = 2, (8×2) = 16,
(3×2) = 6, (2×2) = 4, (9×2) = 18
.IP 2. 4
Sum all the individual digits (digits in parentheses are the products
from Step 1): x (the check digit) + (2) + 7 + (1+6) + 9 + (6) + 7 +
(4) + 9 + (1+8) + 7 = x + 67.
.IP 3. 4
If the sum is a multiple of 10, the account number is possibly
valid. Note that 3 is the only valid digit that produces a sum (70)
that is a multiple of 10.
.IP 4. 4
Thus these account numbers are all invalid except possibly 79927398713
which has the correct check digit.
.RE
.PP
Alternately, you can use the same checksum creation algorithm, ignoring
the checksum already in place as if it had not yet been calculated. Then
calculate the checksum and compare this calculated checksum to the
original checksum included with the credit card number. If the included
checksum matches the calculated checksum, then the number is valid.
.SH STRENGTHS AND WEAKNESSES

The Luhn algorithm will detect any single-digit error, as well as almost
all transpositions of adjacent digits. It will not, however, detect
transposition of the two-digit sequence 09 to 90 (or vice versa). It will
detect 7 of the 10 possible twin errors (it will not detect 22 ↔ 55,
33 ↔ 66 or 44 ↔ 77).
.PP
Other, more complex check-digit algorithms (such as the Verhoeff algorithm
and the Damm algorithm) can detect more transcription errors. The Luhn
mod N algorithm is an extension that supports non-numerical strings.
.PP
Because the algorithm operates on the digits in a right-to-left manner
and zero digits affect the result only if they cause shift in position,
zero-padding the beginning of a string of numbers does not affect the
calculation. Therefore, systems that pad to a specific number of digits
(by converting 1234 to 0001234 for instance) can perform Luhn validation
before or after the padding and achieve the same result.
.PP
Prepending a 0 to odd-length numbers makes it possible to process
the number from left to right rather than right to left, doubling the
odd-place digits.
.PP
The algorithm appeared in a US Patent[2] for a hand-held, mechanical
device for computing the checksum. It was therefore required to be
rather simple. The device took the mod 10 sum by mechanical means. The
substitution digits, that is, the results of the double and reduce
procedure, were not produced mechanically. Rather, the digits were marked
in their permuted order on the body of the machine.
.SH OPTIONS

.TP
.B S
the string of digits to be checked. Spaces and dashes
are ignored.
.SH RESULT

.TP
.B LUHN_CHECKSUM
the Luhn checksum of the string; which is the digits in the
input string with the checksum digit appended.
.SH REFERENCES
From Wikipedia, the free encyclopedia
.PP
.nf
.fam C
       (https://en.wikipedia.org/wiki/Luhn_algorithm)
.fam T
.fi
.SH EXAMPLES
Sample program
.PP
.nf
.fam C
     program demo_luhn_checksum
     use M_hashkeys, only : luhn_checksum
     implicit none
     character(len=:),allocatable :: ccards(:), string
     integer :: i, j
     write(*,*)'GOOD VALUES'
     ccards=[ character(len=20) :: '79927398713', &
                                 & '49927398716',&
                                 & '1234567812345670' ]
     call checkem()
     write(*,*)'BAD VALUES'
     ccards=[ character(len=20) :: &
       & '79927398710', '79927398711', '79927398712', '79927398714',  &
       & '79927398715', '79927398716', '79927398717', '79927398718',  &
       & '79927398719',  &
        '49927398717', '1234567812345678' ]
     call checkem()
     contains
     subroutine checkem
        ! validate these numbers
        do i=1,size(ccards)
           j=len(trim(ccards(i)))
           string=luhn_checksum(ccards(i)(:j-1))
           write(*,'(a,1x,a,1x,l1)')ccards(i),string,ccards(i).eq.string
        enddo

        string='123456 781-234-567'
        write(*,*)'from ',string,' got ',luhn_checksum(string), &
        & ' which should be 1234567812345670'
     end subroutine checkem
     end program demo_luhn_checksum

