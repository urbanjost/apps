." Text automatically generated by txt2man
.TH "djb2_hash" "3m_hashkeys" "March 13, 2022" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." set smaller margin and spacing options
.ta T 0.2i
.nr IN 0.2i
." -----------------------------------------------------------------
.SH NAME
\fBdjb2_hash\fP(3f) - [M_hashkeys:bucket_hash] djb2 string hash (algorithm by Daniel J. Bernstein)
(LICENSE:PD)

.SH SYNOPSIS
function \fBdjb2_hash_arr\fP(anything,continue) \fBresult\fP(\fIhash_128\fP)
.PP
.nf
.fam C
    class(*),intent(in)          :: anything(:)
    logical,intent(in),optional  :: continue
    !! use,intrinsic : ISO_FORTRAN_ENV, only : int64
    integer(kind=int128)         :: hash_128

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
\fBdjb2_hash\fP(3f) is based on the string hash routine commonly known as
\fBdjb2\fP(3c). This algorithm was first described by Dan J. Bernstein many
years ago in comp.lang.c. This version returns a value calculated
using a 64-bit hash, which is returned as a 128bit value (not always
available in Fortran) to allow the value to always be a positive
value; as Fortran does not (currently) support a standard unsigned
integer. If the value is changed to be a 64-bit value on platforms
that do not support 128-bit INTEGER values the value may be negative,
but is otherwise usable.
.PP
Such non-reversible hashes may be used for data or file fingerprints,
to confirm unchanging results during regression testing, \.\.\.
.PP
More information is widely available on string hashes (including the
well-known \fBdjb2\fP(3c) algorithm) on such sources as Wikipedia. Consult
such resources to confirm the suitability of this algorithm for your
use. This algorithm was probably first proposed as a bucket hash.
.PP
The algorithm does not consider the Endian of the programming
environment.
.SH OPTIONS
.TP
.B STR
May be a CHARACTER string or an array of common intrinsic
types. Currently, the types defined in the procedure
are \fBcharacter\fP(len=*); complex; \fBinteger\fP(kind=int8);
\fBinteger\fP(kind=int16); \fBinteger\fP(kind=int32); \fBinteger\fP(kind=int64);
\fBinteger\fP(kind=int128); \fBreal\fP(kind=real32); \fBreal\fP(kind=real64);
\fBreal\fP(kind=real128).
.TP
.B CONTINUE
indicate whether to continue accumulating the hash value
from the last call. This is not threadsafe. This allows
for continued hashes so that a hash can be calculated for
a series of calls.
.SH RETURNS
.TP
.B djb2_hash
A 128-bit INTEGER hash value for the (possibly accumulated) data.
.SH EXAMPLE
Sample program:
.PP
.nf
.fam C
    program demo_djb2_hash
    use M_hashkeys, only : djb2_hash, int128
    implicit none
    integer(kind=int128)         :: hash
    character(len=:),allocatable :: string
    integer                      :: i
    ! string
    string='test djb2_hash'
    hash=djb2_hash(string)
    write(*,*)'string=',string,' hash=',hash
    ! array of characters
    hash=djb2_hash(['t','e','s','t',' ','d','j','b','2','_','h','a','s','h'])
    write(*,*)'string=',string,' hash=',hash
    ! continued hash
    hash=djb2_hash(['t','e','s','t'])
    hash=djb2_hash([' ','d','j','b','2'],continue=.true.)
    hash=djb2_hash(['_','h','a','s','h'],continue=.true.)
    write(*,*)'string=',string,' hash=',hash
    ! array of integers
    hash=djb2_hash([(i,i=0,100)])
    write(*,*)'hash for values 0 to 100 is ',hash
    !
    end program demo_djb2_hash
