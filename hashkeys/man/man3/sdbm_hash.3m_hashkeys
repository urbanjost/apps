." Text automatically generated by txt2man
.TH "sdbm_hash" "3m_hashkeys" "March 13, 2022" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." set smaller margin and spacing options
.ta T 0.2i
.nr IN 0.2i
." -----------------------------------------------------------------
.SH NAME
\fBsdbm_hash\fP(3f) - [M_hashkeys:bucket_hash] sdbm string hash
(LICENSE:PD)

.SH SYNOPSIS
\fBuse,intrinsic\fP : ISO_FORTRAN_ENV, \fIonly\fP : \fIint64\fP
\fBfunction\fP \fBsdbm_hash_arr\fP(anything,continue) \fBresult\fP(hash_128)
.PP
.nf
.fam C
    class(*),intent(in)          :: anything(:)
    logical,intent(in),optional  :: continue
    integer(kind=int128)         :: hash_128

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
\fBsdbm_hash\fP(3f) is based on the string hash routine commonly known as
\fBsdbm\fP(3c).
.PP
this algorithm was created for the sdbm (a public-domain
reimplementation of ndbm) database library. It was found to do well
in scrambling bits, causing good distribution of the keys and fewer
splits. it also happens to be a good general hashing \fBfunction\fP with
good distribution. the actual \fBfunction\fP is
.PP
.nf
.fam C
      hash(i) = hash(i - 1) * 65599 + str[i]

.fam T
.fi
what is available here is the faster version used
in gawk. [there is even a faster, duff-device version]. The magic
constant 65599 was picked out of thin air while experimenting with
different constants, and turns out to be a prime. this is one of the
algorithms used in berkeley db (see sleepycat) and elsewhere.
.PP
This version returns a value calculated using a 64-bit hash, which
is returned as a 128bit value (not always available in Fortran) to
allow the value to always be a positive value; as Fortran does not
(currently) support a standard unsigned integer. If the value is
changed to be a 64-bit value on platforms that do not support 128-bit
INTEGER values the value may be negative, but is otherwise usable.
.PP
Such non-reversible hashes may be used for data or file fingerprints,
to confirm unchanging results during regression testing, \.\.\.
.PP
More information is widely available on string hashes (including the
well-known \fBsdbm\fP(3c) algorithm) on such sources as Wikipedia. Consult
such resources to confirm the suitability of this algorithm for
your use.
.PP
The algorithm does not consider the Endian of the programming
environment.
.SH OPTIONS
.TP
.B STR
May be a CHARACTER string or an array of common intrinsic
types. Currently, the types defined in the procedure
are \fBcharacter\fP(len=*); complex; \fBinteger\fP(kind=int8);
\fBinteger\fP(kind=int16); \fBinteger\fP(kind=int32); \fBinteger\fP(kind=\fIint64\fP);
\fBinteger\fP(kind=int128); \fBreal\fP(kind=real32); \fBreal\fP(kind=real64);
\fBreal\fP(kind=real128).
.TP
.B CONTINUE
indicate whether to continue accumulating the hash value
from the last call. This is not threadsafe. This allows
for continued hashes so that a hash can be calculated for
a series of calls.
.SH RETURNS
.TP
.B sdbm_hash
A 128-bit INTEGER hash value for the (possibly accumulated) data.
.SH EXAMPLE
Sample program:
.PP
.nf
.fam C
    program demo_sdbm_hash
    use M_hashkeys, only : sdbm_hash, int128
    implicit none
    integer(kind=int128)         :: hash
    character(len=:),allocatable :: string
    integer                      :: i
    ! string
    string='test sdbm_hash'
    hash=sdbm_hash(string)
    write(*,*)'string=',string,' hash=',hash
    ! array of characters
    hash=sdbm_hash(['t','e','s','t',' ','s','d','b','m','_','h','a','s','h'])
    write(*,*)'string=',string,' hash=',hash
    ! continued hash
    hash=sdbm_hash(['t','e','s','t'])
    hash=sdbm_hash([' ','s','d','b','m'],continue=.true.)
    hash=sdbm_hash(['_','h','a','s','h'],continue=.true.)
    write(*,*)'string=',string,' hash=',hash
    ! array of integers
    hash=sdbm_hash([(i,i=0,100)])
    write(*,*)'hash for values 0 to 100 is ',hash
    !
    end program demo_sdbm_hash

